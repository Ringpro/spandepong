// GENERATED by @gel/generate v0.6.3

import * as gel from "gel";
import type * as $ from "./reflection";
import * as literal from "./literal";
import type * as _std from "./modules/std";
import type * as _sys from "./modules/sys";
import type * as _stdenc from "./modules/std/enc";
import type * as _schema from "./modules/schema";
import type * as _fts from "./modules/fts";
import type * as _cfg from "./modules/cfg";
import type * as _cal from "./modules/cal";
export interface ScalarAssignableByMap {
  "std::number": _std.$number;
  "sys::VersionStage": _sys.$VersionStage;
  "sys::TransactionIsolation": _sys.$TransactionIsolation;
  "std::uuid": _std.$uuid;
  "std::str": _std.$str;
  "std::json": _std.$json;
  "std::int64": _std.$int64;
  "std::int32": _std.$int32;
  "std::int16": _std.$int16;
  "std::float64": _std.$float64;
  "std::float32": _std.$float32;
  "std::enc::Base64Alphabet": _stdenc.$Base64Alphabet;
  "std::duration": _std.$duration;
  "std::decimal": _std.$decimalλIAssignableBy;
  "std::datetime": _std.$datetime;
  "std::bytes": _std.$bytes;
  "std::bool": _std.$bool;
  "std::bigint": _std.$bigint;
  "std::JsonEmpty": _std.$JsonEmpty;
  "std::Endian": _std.$Endian;
  "schema::Volatility": _schema.$Volatility;
  "schema::TypeModifier": _schema.$TypeModifier;
  "schema::TriggerTiming": _schema.$TriggerTiming;
  "schema::TriggerScope": _schema.$TriggerScope;
  "schema::TriggerKind": _schema.$TriggerKind;
  "schema::TargetDeleteAction": _schema.$TargetDeleteAction;
  "schema::SourceDeleteAction": _schema.$SourceDeleteAction;
  "schema::RewriteKind": _schema.$RewriteKind;
  "schema::ParameterKind": _schema.$ParameterKind;
  "schema::OperatorKind": _schema.$OperatorKind;
  "schema::MigrationGeneratedBy": _schema.$MigrationGeneratedBy;
  "schema::Cardinality": _schema.$Cardinality;
  "schema::AccessPolicyAction": _schema.$AccessPolicyAction;
  "schema::AccessKind": _schema.$AccessKind;
  "fts::document": _fts.$document;
  "fts::Weight": _fts.$Weight;
  "fts::PGLanguage": _fts.$PGLanguage;
  "fts::LuceneLanguage": _fts.$LuceneLanguage;
  "fts::Language": _fts.$Language;
  "fts::ElasticLanguage": _fts.$ElasticLanguage;
  "cfg::memory": _cfg.$memory;
  "cfg::QueryCacheMode": _cfg.$QueryCacheMode;
  "cfg::ConnectionTransport": _cfg.$ConnectionTransport;
  "cfg::AllowBareDDL": _cfg.$AllowBareDDL;
  "cal::relative_duration": _cal.$relative_durationλIAssignableBy;
  "cal::local_time": _cal.$local_time;
  "cal::local_datetime": _cal.$local_datetimeλIAssignableBy;
  "cal::local_date": _cal.$local_date;
  "cal::date_duration": _cal.$date_duration;
}
export type scalarAssignableBy<T extends $.ScalarType> =
  T extends $.ScalarType<infer N extends keyof ScalarAssignableByMap>
    ? ScalarAssignableByMap[N]
    : never

export interface ScalarCastableFromMap {
  "std::number": _std.$number;
  "sys::VersionStage": _sys.$VersionStage;
  "sys::TransactionIsolation": _sys.$TransactionIsolation;
  "std::uuid": _std.$uuid;
  "std::str": _std.$str;
  "std::json": _std.$json;
  "std::int64": _std.$int64;
  "std::int32": _std.$int32;
  "std::int16": _std.$int16;
  "std::float64": _std.$float64;
  "std::float32": _std.$float32;
  "std::enc::Base64Alphabet": _stdenc.$Base64Alphabet;
  "std::duration": _std.$duration;
  "std::decimal": _std.$decimalλICastableTo;
  "std::datetime": _std.$datetime;
  "std::bytes": _std.$bytes;
  "std::bool": _std.$bool;
  "std::bigint": _std.$bigint;
  "std::JsonEmpty": _std.$JsonEmpty;
  "std::Endian": _std.$Endian;
  "schema::Volatility": _schema.$Volatility;
  "schema::TypeModifier": _schema.$TypeModifier;
  "schema::TriggerTiming": _schema.$TriggerTiming;
  "schema::TriggerScope": _schema.$TriggerScope;
  "schema::TriggerKind": _schema.$TriggerKind;
  "schema::TargetDeleteAction": _schema.$TargetDeleteAction;
  "schema::SourceDeleteAction": _schema.$SourceDeleteAction;
  "schema::RewriteKind": _schema.$RewriteKind;
  "schema::ParameterKind": _schema.$ParameterKind;
  "schema::OperatorKind": _schema.$OperatorKind;
  "schema::MigrationGeneratedBy": _schema.$MigrationGeneratedBy;
  "schema::Cardinality": _schema.$Cardinality;
  "schema::AccessPolicyAction": _schema.$AccessPolicyAction;
  "schema::AccessKind": _schema.$AccessKind;
  "fts::document": _fts.$document;
  "fts::Weight": _fts.$Weight;
  "fts::PGLanguage": _fts.$PGLanguage;
  "fts::LuceneLanguage": _fts.$LuceneLanguage;
  "fts::Language": _fts.$Language;
  "fts::ElasticLanguage": _fts.$ElasticLanguage;
  "cfg::memory": _cfg.$memory;
  "cfg::QueryCacheMode": _cfg.$QueryCacheMode;
  "cfg::ConnectionTransport": _cfg.$ConnectionTransport;
  "cfg::AllowBareDDL": _cfg.$AllowBareDDL;
  "cal::relative_duration": _cal.$relative_durationλICastableTo;
  "cal::local_time": _cal.$local_time;
  "cal::local_datetime": _cal.$local_datetimeλICastableTo;
  "cal::local_date": _cal.$local_date;
  "cal::date_duration": _cal.$date_duration;
}
export type scalarCastableFrom<T extends $.ScalarType> =
  T extends $.ScalarType<infer N extends keyof ScalarCastableFromMap>
    ? ScalarCastableFromMap[N]
    : never

type getSharedParentScalar<A, B> =
  A extends $.ScalarType<infer AName> ?
  B extends $.ScalarType<infer BName> ?
    AName extends "std::decimal" ?
      BName extends "std::decimal" ?
        B
      :
      BName extends "std::bigint" ?
        A
      :
      never
    :
    AName extends "std::bigint" ?
      BName extends "std::decimal" ?
        B
      :
      BName extends "std::bigint" ?
        B
      :
      never
    :
    AName extends "cal::relative_duration" ?
      BName extends "cal::relative_duration" ?
        B
      :
      BName extends "cal::date_duration" ?
        A
      :
      never
    :
    AName extends "cal::local_datetime" ?
      BName extends "cal::local_datetime" ?
        B
      :
      BName extends "cal::local_date" ?
        A
      :
      never
    :
    AName extends "cal::local_date" ?
      BName extends "cal::local_datetime" ?
        B
      :
      BName extends "cal::local_date" ?
        B
      :
      never
    :
    AName extends "cal::date_duration" ?
      BName extends "cal::relative_duration" ?
        B
      :
      BName extends "cal::date_duration" ?
        B
      :
      never
    :
    AName extends BName ? A : never
  : never : never;

function getSharedParentScalar<A extends $.ScalarType, B extends $.ScalarType>(a: A, b: B): A | B {
  a = (a as any).__casttype__ || a;
  b = (b as any).__casttype__ || b;
  if (a.__name__ === "std::number") {
    if(b.__name__ === "std::number") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::VersionStage") {
    if(b.__name__ === "sys::VersionStage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::TransactionIsolation") {
    if(b.__name__ === "sys::TransactionIsolation") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::uuid") {
    if(b.__name__ === "std::uuid") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::str") {
    if(b.__name__ === "std::str") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::json") {
    if(b.__name__ === "std::json") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int64") {
    if(b.__name__ === "std::int64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int32") {
    if(b.__name__ === "std::int32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int16") {
    if(b.__name__ === "std::int16") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::float64") {
    if(b.__name__ === "std::float64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::float32") {
    if(b.__name__ === "std::float32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::enc::Base64Alphabet") {
    if(b.__name__ === "std::enc::Base64Alphabet") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::duration") {
    if(b.__name__ === "std::duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::decimal") {
    if(b.__name__ === "std::decimal") {
      return b;
    }
    if(b.__name__ === "std::bigint") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::datetime") {
    if(b.__name__ === "std::datetime") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bytes") {
    if(b.__name__ === "std::bytes") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bool") {
    if(b.__name__ === "std::bool") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bigint") {
    if(b.__name__ === "std::decimal") {
      return b;
    }
    if(b.__name__ === "std::bigint") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::JsonEmpty") {
    if(b.__name__ === "std::JsonEmpty") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::Endian") {
    if(b.__name__ === "std::Endian") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::Volatility") {
    if(b.__name__ === "schema::Volatility") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TypeModifier") {
    if(b.__name__ === "schema::TypeModifier") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerTiming") {
    if(b.__name__ === "schema::TriggerTiming") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerScope") {
    if(b.__name__ === "schema::TriggerScope") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerKind") {
    if(b.__name__ === "schema::TriggerKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TargetDeleteAction") {
    if(b.__name__ === "schema::TargetDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::SourceDeleteAction") {
    if(b.__name__ === "schema::SourceDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::RewriteKind") {
    if(b.__name__ === "schema::RewriteKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::ParameterKind") {
    if(b.__name__ === "schema::ParameterKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::OperatorKind") {
    if(b.__name__ === "schema::OperatorKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::MigrationGeneratedBy") {
    if(b.__name__ === "schema::MigrationGeneratedBy") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::Cardinality") {
    if(b.__name__ === "schema::Cardinality") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::AccessPolicyAction") {
    if(b.__name__ === "schema::AccessPolicyAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::AccessKind") {
    if(b.__name__ === "schema::AccessKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "fts::document") {
    if(b.__name__ === "fts::document") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "fts::Weight") {
    if(b.__name__ === "fts::Weight") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "fts::PGLanguage") {
    if(b.__name__ === "fts::PGLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "fts::LuceneLanguage") {
    if(b.__name__ === "fts::LuceneLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "fts::Language") {
    if(b.__name__ === "fts::Language") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "fts::ElasticLanguage") {
    if(b.__name__ === "fts::ElasticLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::memory") {
    if(b.__name__ === "cfg::memory") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::QueryCacheMode") {
    if(b.__name__ === "cfg::QueryCacheMode") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::ConnectionTransport") {
    if(b.__name__ === "cfg::ConnectionTransport") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::AllowBareDDL") {
    if(b.__name__ === "cfg::AllowBareDDL") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cal::relative_duration") {
    if(b.__name__ === "cal::relative_duration") {
      return b;
    }
    if(b.__name__ === "cal::date_duration") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cal::local_time") {
    if(b.__name__ === "cal::local_time") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cal::local_datetime") {
    if(b.__name__ === "cal::local_datetime") {
      return b;
    }
    if(b.__name__ === "cal::local_date") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cal::local_date") {
    if(b.__name__ === "cal::local_datetime") {
      return b;
    }
    if(b.__name__ === "cal::local_date") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cal::date_duration") {
    if(b.__name__ === "cal::relative_duration") {
      return b;
    }
    if(b.__name__ === "cal::date_duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
}

const implicitCastMap = new Map<string, Set<string>>([
  ["cal::date_duration", new Set(["cal::relative_duration"])],
  ["cal::local_date", new Set(["cal::local_datetime"])],
  ["std::bigint", new Set(["std::decimal"])],
]);
function isImplicitlyCastableTo(from: string, to: string): boolean {
  const _a = implicitCastMap.get(from),
        _b = _a != null ? _a.has(to) : null;
  return _b != null ? _b : false;
};

export type scalarLiterals =
  | number
  | string
  | boolean
  | bigint
  | Uint8Array
  | Date
  | gel.Duration
  | gel.ConfigMemory
  | Float32Array
  | gel.LocalDateTime
  | gel.LocalDate
  | gel.LocalTime
  | gel.RelativeDuration
  | gel.DateDuration
  | gel.Range<any> | gel.MultiRange<any>;

type getTsType<T extends $.BaseType> = T extends $.ScalarType
  ? T extends _fts.$document | _std.$decimal | _std.$json | _std.$uuid
    ? never
    : T["__tstype__"]
  : T extends $.RangeType
  ? gel.Range<T['__element__']['__tstype__']>
  : T extends $.MultiRangeType
  ? gel.MultiRange<T['__element__']['__tstype__']>
  : never;
export type orScalarLiteral<T extends $.TypeSet> =
  | T
  | ($.BaseTypeSet extends T      ? scalarLiterals      : $.Cardinality extends T["__cardinality__"]        ? getTsType<T["__element__"]>        : $.computeTsTypeCard<            getTsType<T["__element__"]>,            T["__cardinality__"]          >);
export type scalarWithConstType<
  T extends $.ScalarType,
  TsConstType
> = $.ScalarType<
  T["__name__"],
  T["__tstype__"],
  T['__tsargtype__'],
  TsConstType
>;
export type literalToScalarType<T extends any> =
  T extends number ? scalarWithConstType<_std.$number, T> :
  T extends string ? scalarWithConstType<_std.$str, T> :
  T extends boolean ? scalarWithConstType<_std.$bool, T> :
  T extends bigint ? scalarWithConstType<_std.$bigint, T> :
  T extends Uint8Array ? scalarWithConstType<_std.$bytes, T> :
  T extends Date ? scalarWithConstType<_std.$datetime, T> :
  T extends gel.Duration ? scalarWithConstType<_std.$duration, T> :
  T extends gel.ConfigMemory ? scalarWithConstType<_cfg.$memory, T> :
  T extends gel.LocalDateTime ? scalarWithConstType<_cal.$local_datetime, T> :
  T extends gel.LocalDate ? scalarWithConstType<_cal.$local_date, T> :
  T extends gel.LocalTime ? scalarWithConstType<_cal.$local_time, T> :
  T extends gel.RelativeDuration ? scalarWithConstType<_cal.$relative_duration, T> :
  T extends gel.DateDuration ? scalarWithConstType<_cal.$date_duration, T> :
  T extends gel.Range<infer E> ? $.RangeType<literalToScalarType<E>> :
  T extends gel.MultiRange<infer E> ? $.MultiRangeType<literalToScalarType<E>> :
  $.BaseType;

type literalToTypeSet<T extends any> = T extends $.TypeSet
  ? T
  : $.$expr_Literal<literalToScalarType<T>>;

export type mapLiteralToTypeSet<T> = {
  [k in keyof T]: literalToTypeSet<T[k]>;
};

function literalToTypeSet(type: any): $.TypeSet {
  if (type && type.__element__) {
    return type;
  }
  if (typeof type === "number") {
    return literal.$getType("00000000-0000-0000-0000-0000000001ff")(type);
  }
  if (typeof type === "string") {
    return literal.$getType("00000000-0000-0000-0000-000000000101")(type);
  }
  if (typeof type === "boolean") {
    return literal.$getType("00000000-0000-0000-0000-000000000109")(type);
  }
  if (typeof type === "bigint") {
    return literal.$getType("00000000-0000-0000-0000-000000000110")(type);
  }
  if (type instanceof Uint8Array) {
    return literal.$getType("00000000-0000-0000-0000-000000000102")(type);
  }
  if (type instanceof Date) {
    return literal.$getType("00000000-0000-0000-0000-00000000010a")(type);
  }
  if (type instanceof gel.Duration) {
    return literal.$getType("00000000-0000-0000-0000-00000000010e")(type);
  }
  if (type instanceof gel.ConfigMemory) {
    return literal.$getType("00000000-0000-0000-0000-000000000130")(type);
  }
  if (type instanceof gel.LocalDateTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010b")(type);
  }
  if (type instanceof gel.LocalDate) {
    return literal.$getType("00000000-0000-0000-0000-00000000010c")(type);
  }
  if (type instanceof gel.LocalTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010d")(type);
  }
  if (type instanceof gel.RelativeDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000111")(type);
  }
  if (type instanceof gel.DateDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000112")(type);
  }
  throw new Error(`Cannot convert literal '${type}' into scalar type`);
}


export { getSharedParentScalar, isImplicitlyCastableTo, literalToTypeSet };
